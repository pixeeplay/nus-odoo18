import logging
import re
import json
import base64
import requests
from odoo import models, fields, api, _
from odoo.exceptions import UserError

_logger = logging.getLogger(__name__)


class ProductTemplate(models.Model):
    _inherit = 'product.template'

    chatgpt_enriched = fields.Boolean(
        string='Enriched by ChatGPT',
        default=False,
        readonly=True,
        help='Indicates if this product has been enriched by ChatGPT'
    )
    
    chatgpt_content = fields.Html(
        string='AI Generated Content',
        readonly=True,
        help='Content generated by ChatGPT'
    )
    
    chatgpt_last_enrichment = fields.Datetime(
        string='Last Enrichment Date',
        readonly=True,
        help='Date and time of last ChatGPT enrichment'
    )
    
    chatgpt_media_urls = fields.Text(
        string='AI Discovered Media',
        readonly=True,
        help='URLs of official images and videos found by AI'
    )

    chatgpt_log = fields.Html(string='Enrichment Log', readonly=True)
    chatgpt_web_search_log = fields.Html(string='Web Search Log', readonly=True)
    chatgpt_deep_enrichment_log = fields.Html(string='Deep Enrichment Log', readonly=True)
    chatgpt_last_enrichment = fields.Datetime(string='Last AI Enrichment', readonly=True)
    chatgpt_auto_align = fields.Boolean(string='Auto-Align Market Price', default=True, help="If checked, this product will be automatically processed by the scheduler.")
    chatgpt_raw_serp_results = fields.Html(string='Raw Search Data', readonly=True)
    chatgpt_suggested_price = fields.Float(string='AI Suggested Price', compute='_compute_suggested_price', help="Suggested price based on global alignment strategy.")
    chatgpt_debug_show_raw = fields.Boolean(related='chatgpt_config_id.debug_show_raw_results', string="Show Raw Search Data")

    chatgpt_competitor_price_ids = fields.One2many(
        'product.competitor.price', 'product_tmpl_id', 
        string='Competitor Prices (France)'
    )
    
    chatgpt_video_ids = fields.One2many(
        'product.video.link', 'product_tmpl_id', 
        string='Official Videos'
    )

    chatgpt_discovered_media_ids = fields.One2many(
        'product.discovered.media', 'product_tmpl_id',
        string='Discovered Media'
    )

    chatgpt_config_id = fields.Many2one('chatgpt.config', compute='_compute_chatgpt_config', string='Active AI Configuration')
    chatgpt_prompt_ids = fields.Many2many('chatgpt.product.prompt', string='Active Prompts', compute='_compute_chatgpt_config')

    # -------------------------------------------------------
    # AI Enrichment Pipeline Fields (ai_* prefix)
    # -------------------------------------------------------
    ai_seo_title = fields.Char(string='Titre SEO', size=70, readonly=True)
    ai_meta_description = fields.Char(string='Meta Description', size=160, readonly=True)
    ai_short_description = fields.Text(string='Description courte IA', readonly=True)
    ai_description_html = fields.Html(string='Description longue IA', readonly=True)
    ai_bullet_points = fields.Text(string='Points clés', readonly=True)
    ai_tags = fields.Char(string='Tags SEO', size=500, readonly=True)
    ai_suggested_category = fields.Char(string='Catégorie suggérée', readonly=True)
    ai_detected_brand = fields.Char(string='Marque détectée', readonly=True)
    ai_target_audience = fields.Char(string='Public cible', readonly=True)
    ai_selling_points = fields.Text(string='Arguments de vente', readonly=True)
    ai_technical_specs = fields.Text(string='Specs techniques (JSON)', readonly=True)
    ai_estimated_weight = fields.Float(string='Poids estimé (kg)', readonly=True)
    ai_confidence = fields.Selection([
        ('high', 'Haute'),
        ('medium', 'Moyenne'),
        ('low', 'Basse'),
    ], string='Confiance IA', readonly=True)
    ai_enrichment_date = fields.Datetime(string='Date enrichissement IA', readonly=True)
    ai_enrichment_source = fields.Char(string='Source enrichissement', readonly=True)

    ai_enrichment_queue_ids = fields.One2many(
        'product.enrichment.queue', 'product_id',
        string='Enrichment Queue History')
    ai_queue_count = fields.Integer(
        compute='_compute_ai_queue_count', string='Queue Items')

    def _compute_ai_queue_count(self):
        for rec in self:
            rec.ai_queue_count = len(rec.ai_enrichment_queue_ids)

    # -------------------------------------------------------
    # Queue Actions
    # -------------------------------------------------------
    def action_ai_enqueue(self):
        """Add this product to the AI enrichment queue with high priority."""
        self.ensure_one()
        if not self.name:
            raise UserError(_('Product must have a name before enrichment.'))

        existing = self.env['product.enrichment.queue'].search([
            ('product_id', '=', self.id),
            ('state', 'not in', ['done', 'error', 'skipped']),
        ], limit=1)
        if existing:
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': _('Déjà en file d\'attente'),
                    'message': _("'%s' est déjà en file d'attente (état: %s).") % (
                        self.name, existing.state),
                    'type': 'warning',
                    'sticky': False,
                },
            }

        self.env['product.enrichment.queue'].create({
            'product_id': self.id,
            'priority': '2',  # High priority for manual enqueue
        })
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Ajouté à la file d\'attente'),
                'message': _("'%s' ajouté à la file d'attente IA (priorité haute).") % self.name,
                'type': 'success',
                'sticky': False,
            },
        }

    def action_ai_apply_to_standard(self):
        """Copy ai_* fields to standard Odoo fields."""
        self.ensure_one()
        vals = {}
        mapping = {
            'ai_description_html': 'website_description',
            'ai_short_description': 'description_sale',
            'ai_seo_title': 'website_meta_title',
            'ai_meta_description': 'website_meta_description',
        }
        for ai_field, std_field in mapping.items():
            ai_value = getattr(self, ai_field, None)
            if ai_value and std_field in self._fields:
                vals[std_field] = ai_value

        if vals:
            self.write(vals)
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': _('Champs mis à jour'),
                    'message': _("%d champ(s) standard mis à jour depuis les données IA.") % len(vals),
                    'type': 'success',
                    'sticky': False,
                },
            }
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Rien à appliquer'),
                'message': _("Aucune donnée IA disponible à appliquer."),
                'type': 'warning',
                'sticky': False,
            },
        }

    def action_ai_view_queue(self):
        """Open enrichment queue for this product."""
        self.ensure_one()
        return {
            'name': _('File d\'attente — %s') % self.name,
            'type': 'ir.actions.act_window',
            'res_model': 'product.enrichment.queue',
            'view_mode': 'list,form',
            'domain': [('product_id', '=', self.id)],
        }

    def action_ai_clear(self):
        """Clear AI enrichment pipeline data."""
        self.ensure_one()
        ai_fields = {f: False for f in self._fields if f.startswith('ai_') and f not in (
            'ai_enrichment_queue_ids', 'ai_queue_count')}
        self.write(ai_fields)
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Données IA effacées'),
                'message': _('Les champs d\'enrichissement IA ont été vidés.'),
                'type': 'info',
                'sticky': False,
            },
        }

    def _compute_chatgpt_config(self):
        config = self.env['chatgpt.config'].search([('active', '=', True)], limit=1)
        for record in self:
            record.chatgpt_config_id = config.id
            record.chatgpt_prompt_ids = config.prompt_ids.ids if config else []

    @api.model_create_multi
    def create(self, vals_list):
        """Override create to auto-enrich products if enabled"""
        records = super(ProductTemplate, self).create(vals_list)
        
        # Check if auto-enrichment is enabled
        try:
            config = self.env['chatgpt.config'].get_active_config()
            if config.auto_enrich:
                for record in records:
                    if record.name and not record.chatgpt_enriched:
                        try:
                            record._enrich_with_chatgpt()
                        except Exception as e:
                            _logger.warning('Auto-enrichment failed for product %s: %s', record.name, str(e))
                            # Don't block product creation if enrichment fails
        except Exception as e:
            _logger.warning('Could not check auto-enrich config: %s', str(e))
            
        return records

    def action_enrich_with_chatgpt(self):
        """Manual action to enrich product with ChatGPT"""
        self.ensure_one()
        
        if not self.name:
            raise UserError(_('Product must have a name before enrichment.'))
        
        self._enrich_with_chatgpt()
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Success'),
                'message': _('Product enriched successfully with ChatGPT!'),
                'type': 'success',
                'sticky': False,
            }
        }

    def _enrich_with_chatgpt(self):
        """Internal method to enrich product using multiple prompts from config"""
        self.ensure_one()
        
        # Get active configuration
        config = self.env['chatgpt.config'].get_active_config()
        
        if not config.prompt_ids:
            raise UserError(_('No prompts configured in ChatGPT Configuration.'))
        
        _logger.info('Enriching product: %s', self.name)
        
        vals = {
            'chatgpt_enriched': True,
            'chatgpt_last_enrichment': fields.Datetime.now(),
            'chatgpt_log': f"<p>Starting enrichment for <b>{self.name}</b>...</p>",
        }
        
        # 0. SearXNG Web Search (if enabled) - adds context from fresh web data
        scraped_data = ""
        if config.searxng_enabled:
            try:
                client = config._get_searxng_client()
                ean = getattr(self, 'barcode', '') or ''
                brand = ''
                if hasattr(self, 'product_brand_id') and self.product_brand_id:
                    brand = self.product_brand_id.name
                result = client.search_product(self.name, ean=ean, brand=brand)
                for r in result.get('results', [])[:8]:
                    title = r.get('title', '')
                    content = r.get('content', '')[:500]
                    url = r.get('url', '')
                    scraped_data += f"\n[{title}]({url}): {content}\n"
                vals['chatgpt_web_search_log'] = (
                    f"<p><i class='fa fa-search'/> SearXNG: {len(result.get('results', []))} results</p>"
                    f"<pre>{scraped_data[:3000]}</pre>"
                )
            except Exception as e:
                _logger.warning("SearXNG search failed for %s: %s", self.name, e)

        # 1. Technical Fact Discovery (Web Search) - SPECIFICATIONS ONLY
        if config.use_web_search:
            vals['chatgpt_web_search_log'] = f"<p><i class='fa fa-microchip'/> Researching technical characteristics...</p>"
            # Use custom technical prompt if available
            tech_prompt = (config.prompt_technical_research or "Research ONLY technical specifications for {product_name}.").format(product_name=self.name)
            research_res = config.call_ai_api(tech_prompt)
            research_res = re.sub(r'```(html|json|xml)?', '', research_res).replace('```', '').strip()
            vals['chatgpt_web_search_log'] += f"<div class='research-results'>{research_res}</div>"
            scraped_data += f"\n--- Technical Web Research ---\n{research_res}\n"

        # 2. Scraping Layer (Deep Enrichment) - INCLUDES PRICES
        if config.use_deep_enrichment:
            deep_log = f"<p><i class='fa fa-deep-enrichment'/> Running Deep Scraping phase...</p><ul>"
            raw_serp = "<div class='serp-results'><h5><i class='fa fa-google mr-2 text-primary'/> Market Data Discovery</h5>"
            if config.target_competitors:
                raw_serp += f"<div class='alert alert-info py-1 mb-2'>Targeting: {config.target_competitors.replace('\\n', ', ')}</div>"
            raw_serp += "<div class='list-group list-group-flush border rounded'>"
            
            search_query = self.name
            if config.target_competitors:
                search_query += " (" + " OR ".join(config.target_competitors.splitlines()) + ")"
                
            search_results = config._search_with_serpapi(search_query)[:max(1, config.max_scrape_pages or 3)]
            for res in search_results:
                url = res.get('link')
                title = res.get('title', 'Unknown Title')
                snippet = res.get('snippet', '')
                if not url: continue
                
                deep_log += f"<li>Analyzing <a href='{url}' target='_blank'>{title}</a>...</li>"
                raw_serp += f"<div class='list-group-item p-2'><a href='{url}' target='_blank' class='fw-bold'>{title}</a><br/><small class='text-muted' style='font-size: 0.8em;'>{snippet}</small></div>"
                
                content = config._scrape_with_scrapingbee(url)
                scraped_data += f"\n--- Content from {title} ({url}) ---\n{content}\n"
            
            deep_log += "</ul>"
            raw_serp += "</div></div>"
            vals['chatgpt_deep_enrichment_log'] = deep_log
            vals['chatgpt_raw_serp_results'] = raw_serp
        
        all_content = []
        
        system_instruction = (
            "You are an expert product data analyst. Always provide accurate technical details. "
            "IMPORTANT: Return ONLY clean text or HTML as requested. NO markdown backticks. "
            "For product descriptions, return ONLY the description content, NO field labels like 'Description:' or JSON syntax. "
            "If JSON is requested, use these exact keys: 'weight', 'description_sale', "
            "'prices_france' (list of {'source': domain, 'price': float, 'url': url} - aim for 5+ competitors), "
            "'youtube_videos' (list of {'name': title, 'url': url}), "
            "'technical_bullets' (list of strings)."
        )

        for p in config.prompt_ids:
            if not p.active:
                continue
                
            prompt = f"{system_instruction}\nAnswer in {dict(p._fields['language'].selection).get(p.language, 'French')}. "
            if scraped_data:
                prompt += f"CONTEXT DATA:\n{scraped_data}\n"
            prompt += p.prompt_template.format(product_name=self.name)
            
            if "JSON" in prompt.upper() or "STRUCTURED" in prompt.upper():
                prompt += "\nReturn ONLY valid JSON."
            
            enriched_content = config.call_ai_api(prompt)
            # Remove markdown backticks
            enriched_content = re.sub(r'```(html|json|xml)?', '', enriched_content).replace('```', '').strip()
            
            vals['chatgpt_log'] += f"<p><b>Prompt '{p.name}':</b> Executed.</p>"
            
            try:
                # Attempt to extract JSON even if there's other text
                json_start = enriched_content.find('{')
                json_end = enriched_content.rfind('}') + 1
                if json_start >= 0 and json_end > json_start:
                    maybe_json = enriched_content[json_start:json_end]
                    json_data = json.loads(maybe_json)
                    
                    if 'prices_france' in json_data and isinstance(json_data['prices_france'], list):
                        self.chatgpt_competitor_price_ids.unlink() # Refresh prices
                        for pr in json_data['prices_france']:
                            if pr.get('price'):
                                self.env['product.competitor.price'].create({
                                    'product_tmpl_id': self.id,
                                    'source': pr.get('source'),
                                    'price': float(pr.get('price', 0)),
                                    'url': pr.get('url'),
                                })

                    if 'youtube_videos' in json_data and isinstance(json_data['youtube_videos'], list):
                        # Don't unlink, just update/append unique ones
                        for v in json_data['youtube_videos']:
                            if v.get('url'):
                                if not self.chatgpt_video_ids.filtered(lambda x: x.video_url == v.get('url')):
                                    self.env['product.video.link'].create({
                                        'product_tmpl_id': self.id,
                                        'name': v.get('name') or _('Official Media'),
                                        'video_url': v.get('url'),
                                        'platform': 'youtube'
                                    })

                    media_keys = ['image_urls', 'images', 'media']
                    for mk in media_keys:
                        if mk in json_data and isinstance(json_data[mk], list):
                            self._import_media_from_urls(json_data[mk])

                    for key, value in json_data.items():
                        if key in self._fields and not vals.get(key) and key not in ['chatgpt_competitor_price_ids', 'chatgpt_video_ids']:
                            field = self._fields[key]
                            
                            # ROBUST TYPE CONVERSION (Fixes RPC_ERROR ValueError)
                            if value in [None, 'N/A', 'n/a', '', 'None']:
                                continue
                                
                            try:
                                if field.type in ['float', 'monetary']:
                                    # Extract number even if it has currency symbols
                                    if isinstance(value, str):
                                        nums = re.findall(r'(\d+[.,]\d+|\d+)', value)
                                        value = float(nums[0].replace(',', '.')) if nums else 0.0
                                    vals[key] = float(value)
                                elif field.type == 'integer':
                                    vals[key] = int(float(value)) if value else 0
                                elif field.type == 'boolean':
                                    vals[key] = bool(value)
                                elif key == 'description_sale' and isinstance(value, str):
                                    clean_val = re.sub(r'^\{?"description_sale":\s*"?', '', value)
                                    clean_val = re.sub(r'"?\}?$', '', clean_val).strip()
                                    vals[key] = clean_val
                                else:
                                    vals[key] = value
                            except (ValueError, TypeError, IndexError):
                                _logger.warning("Failed to convert value %s for field %s", value, key)
                                continue
                    
                    # If we mapped a description, use it as the clean content for the dashboard
                    if 'description_sale' in json_data:
                        enriched_content = json_data['description_sale']
                else:
                    # Not JSON, but let's clean it anyway for the dashboard
                    enriched_content = re.sub(r'^\{?"description_sale":\s*"?', '', enriched_content)
                    enriched_content = re.sub(r'"?\}?$', '', enriched_content).strip()

            except Exception as e:
                _logger.warning('Failed to parse AI response as JSON or clean it: %s', str(e))

            if p.target_field_id and p.target_field_id.name in self._fields:
                vals[p.target_field_id.name] = enriched_content
            
            # Universal media extraction from raw text (back-up)
            urls = re.findall(r'https?://[^\s<>"]+|www\.[^\s<>"]+', enriched_content)
            if urls:
                self._import_media_from_urls(urls)
                for url in urls:
                    if 'youtube.com' in url or 'youtu.be' in url:
                        if not self.chatgpt_video_ids.filtered(lambda v: v.video_url == url):
                            self.env['product.video.link'].create({
                                'product_tmpl_id': self.id,
                                'name': _('Official Discovery'),
                                'video_url': url,
                                'platform': 'youtube'
                            })
                
                existing_media_urls = vals.get('chatgpt_media_urls', '') or ''
                new_media_urls = "\n".join(list(set(urls)))
                vals['chatgpt_media_urls'] = (existing_media_urls + "\n" + new_media_urls).strip()
            
            all_content.append(enriched_content) # Just content for clean look
            
        vals['chatgpt_content'] = "\n\n".join(all_content)
        vals['chatgpt_log'] += "<p class='text-success'><b>Done!</b> Enrichment completed.</p>"
        self.write(vals)
        
        # Trigger alignment if global config says so
        if config.price_alignment_strategy != 'none':
            self.action_align_price(raise_error=False)
        
    def _compute_suggested_price(self):
        config = self.env['chatgpt.config'].get_active_config()
        for record in self:
            record.chatgpt_suggested_price = 0
            if record.chatgpt_competitor_price_ids and config.price_alignment_strategy != 'none':
                prices = record.chatgpt_competitor_price_ids.filtered(lambda p: p.price > 0).mapped('price')
                if prices:
                    target = 0
                    if config.price_alignment_strategy == 'lowest':
                        target = min(prices)
                    elif config.price_alignment_strategy == 'average':
                        target = sum(prices) / len(prices)
                    
                    if target > 0:
                        offset = config.price_alignment_offset
                        if config.price_alignment_offset_type == 'percentage':
                            offset = (target * config.price_alignment_offset_pct) / 100.0
                        record.chatgpt_suggested_price = target + offset
        
        _logger.info('Product %s enriched successfully', self.name)

    def action_align_price(self, raise_error=True):
        """Align product price based on competitors"""
        self.ensure_one()
        if self.chatgpt_suggested_price > 0:
            old_price = self.list_price
            self.list_price = self.chatgpt_suggested_price
            msg = _("<b>Price Alignment:</b> Sale price updated from %s to <b>%s</b> based on AI market analysis.") % (old_price, self.list_price)
            self.message_post(body=msg)
        elif raise_error:
            raise UserError(_("No suggested price available. Ensure competitor prices are extracted first."))
        else:
            _logger.info("No suggested price available for %s, skipping alignment.", self.name)

    def _import_media_from_urls(self, urls):
        """Download images from URLs and import them into Odoo"""
        if not urls:
            return
            
        processed_urls = []
        for url in urls:
            if not any(ext in url.lower() for ext in ['.jpg', '.jpeg', '.png', '.webp']):
                continue
            if url in processed_urls:
                continue
            
            try:
                _logger.info('Importing image: %s', url)
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                }
                response = requests.get(url, timeout=10, headers=headers, verify=False)
                if response.status_code == 200:
                    image_data = base64.b64encode(response.content)
                    
                    # Set main image if not already set
                    if not self.image_1920:
                        self.image_1920 = image_data
                        _logger.info('Set main product image from %s', url)
                    else:
                        # Add to extra media
                        # Check if already exists
                        existing = self.env['product.image'].search([
                            ('product_tmpl_id', '=', self.id),
                            ('name', 'ilike', url.split('/')[-1][:10])
                        ], limit=1)
                        
                        if not existing:
                            self.env['product.image'].create({
                                'name': url.split('/')[-1] or 'AI Discovered Image',
                                'product_tmpl_id': self.id,
                                'image_1920': image_data,
                            })
                            _logger.info('Added extra media from %s', url)
                
                processed_urls.append(url)
                if len(processed_urls) >= 10: # Increased limit
                    break
            except Exception as e:
                _logger.warning('Failed to import image from %s: %s', url, str(e))

    def action_run_deep_search(self):
        """Dedicated action for deep enrichment phase only"""
        self.ensure_one()
        # Force set config to use deep enrichment for this run
        config = self.env['chatgpt.config'].get_active_config()
        if not config.use_deep_enrichment:
            raise UserError(_("Deep Enrichment is disabled in global settings. Please enable it first."))
        return self.action_enrich_with_chatgpt()

    def action_enrich_batch(self):
        """Action for batch enrichment of multiple products"""
        for record in self:
            try:
                record._enrich_with_chatgpt()
            except Exception as e:
                _logger.error('Batch enrichment failed for %s: %s', record.name, str(e))
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Batch Enrichment'),
                'message': _('Enrichment process completed for selected products.'),
                'type': 'success',
                'sticky': False,
            }
        }

    def action_clear_enrichment(self):
        """Clear ChatGPT enrichment data"""
        self.ensure_one()
        vals = {
            'chatgpt_enriched': False,
            'chatgpt_content': False,
            'chatgpt_last_enrichment': False,
            'chatgpt_media_urls': False,
        }
        if 'description_sale' in self._fields:
            vals['description_sale'] = False
        if 'description' in self._fields:
            vals['description'] = False
        if 'website_description' in self._fields:
            vals['website_description'] = False
            
        self.write(vals)
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Success'),
                'message': _('ChatGPT enrichment data cleared.'),
                'type': 'info',
                'sticky': False,
            }
        }

    def action_view_chatgpt_enrichment(self):
        """Dummy action for stat button to satisfy Odoo requirements"""
        return True


    def action_apply_competitor_price(self, price_id):
        """Manually apply a specific competitor price as the product list price"""
        self.ensure_one()
        price_rec = self.env['product.competitor.price'].browse(price_id)
        if price_rec.exists():
            old_price = self.list_price
            self.list_price = price_rec.price
            msg = _("<b>Manual Price Override:</b> Price updated from %s to <b>%s</b> based on competitor: %s") % (old_price, self.list_price, price_rec.source)
            self.message_post(body=msg)

    def action_set_main_video(self, video_id):
        """Set a discovered video as the primary one (currently just logs/notifies as Odoo 18 core doesn't have a single main video field by default outside of website_sale)"""
        self.ensure_one()
        video_rec = self.env['product.video.link'].browse(video_id)
        if video_rec.exists():
            msg = _("<b>Manual Video Selection:</b> '%s' was selected as the preferred official video.") % (video_rec.name)
            self.message_post(body=msg)

    def action_find_official_images(self):
        """Dedicated action to find official images using SerpApi Image Engine"""
        self.ensure_one()
        config = self.env['chatgpt.config'].get_active_config()
        if not config.serpapi_key:
            raise UserError(_("SerpApi Key is required for image discovery. Please configure it in AI Settings."))
        
        _logger.info("Starting official image discovery for: %s", self.name)
        search_query = f"{self.name} official product photo"
        if self.default_code:
            search_query += f" {self.default_code}"
            
        results = config._search_with_serpapi(search_query, engine='google_images')
        
        # Clear previous discovery
        self.chatgpt_discovered_media_ids.unlink()
        
        for res in results:
            url = res.get('original') or res.get('thumbnail')
            if not url: continue
            
            # Create discovery record - we'll compute preview on the fly or via button
            self.env['product.discovered.media'].create({
                'product_tmpl_id': self.id,
                'name': res.get('title', 'Discovered Photo'),
                'url': url,
                'source': res.get('source', 'Web'),
            })
            
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Image Discovery'),
                'message': _('Found %s potential official images.') % len(results),
                'type': 'success',
                'sticky': False,
            }
        }


class ProductCompetitorPrice(models.Model):
    _name = 'product.competitor.price'
    _description = 'Competitor Price Tracking'

    product_tmpl_id = fields.Many2one('product.template', string='Product', ondelete='cascade')
    source = fields.Char(string='Source (Domain)')
    price = fields.Float(string='Price')
    currency_id = fields.Many2one('res.currency', string='Currency', default=lambda self: self.env.ref('base.EUR').id)
    url = fields.Char(string='URL')
    last_update = fields.Datetime(string='Last Scraped', default=fields.Datetime.now)

    def action_apply_this_price(self):
        """Proxy to parent model action"""
        self.ensure_one()
        self.product_tmpl_id.action_apply_competitor_price(self.id)


class ProductVideoLink(models.Model):
    _name = 'product.video.link'
    _description = 'Official Video Links'

    product_tmpl_id = fields.Many2one('product.template', string='Product', ondelete='cascade')
    name = fields.Char(string='Title')
    video_url = fields.Char(string='Video URL')
    platform = fields.Selection([('youtube', 'YouTube'), ('other', 'Other')], string='Platform', default='youtube')
    icon = fields.Char(compute='_compute_icon')

    @api.depends('platform')
    def _compute_icon(self):
        for record in self:
            if record.platform == 'youtube':
                record.icon = 'fa-youtube'
            else:
                record.icon = 'fa-play-circle'

    def action_open_video(self):
        """Redirect to the video URL"""
        self.ensure_one()
        return {
            'type': 'ir.actions.act_url',
            'url': self.video_url,
            'target': 'new',
        }

    def action_set_primary(self):
        """Proxy to parent model action"""
        self.ensure_one()
        self.product_tmpl_id.action_set_main_video(self.id)



class ProductDiscoveredMedia(models.Model):
    _name = 'product.discovered.media'
    _description = 'Discovered Product Media'

    product_tmpl_id = fields.Many2one('product.template', string='Product', ondelete='cascade')
    name = fields.Char(string='Title')
    url = fields.Char(string='URL')
    source = fields.Char(string='Source')
    image_preview = fields.Binary(string='Preview', compute='_compute_preview', store=True)
    
    @api.depends('url')
    def _compute_preview(self):
        for record in self:
            if record.url:
                try:
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                    }
                    # We use a small timeout and verify=False to be robust
                    response = requests.get(record.url, timeout=5, headers=headers, verify=False)
                    if response.status_code == 200:
                        record.image_preview = base64.b64encode(response.content)
                    else:
                        record.image_preview = False
                except Exception:
                    record.image_preview = False

    def action_import_as_main(self):
        """Set this image as the main product image"""
        self.ensure_one()
        if not self.image_preview:
            # Force download if preview failed
            self._compute_preview()
            
        if self.image_preview:
            self.product_tmpl_id.image_1920 = self.image_preview
            self.product_tmpl_id.message_post(body=_("<b>Media Discovery:</b> Main image updated from discovered URL: %s") % self.url)
        else:
            raise UserError(_("Could not download this image. Please try another one."))

    def action_import_to_gallery(self):
        """Add this image to the Odoo extra media gallery"""
        self.ensure_one()
        if not self.image_preview:
            self._compute_preview()
            
        if self.image_preview:
            self.env['product.image'].create({
                'name': self.name or _('AI Discovered Image'),
                'product_tmpl_id': self.product_tmpl_id.id,
                'image_1920': self.image_preview,
            })
            self.product_tmpl_id.message_post(body=_("<b>Media Discovery:</b> Added new extra media image from: %s") % self.url)
        else:
            raise UserError(_("Could not download this image. Please try another one."))
