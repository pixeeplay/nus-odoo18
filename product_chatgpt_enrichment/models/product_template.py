import logging
import re
import json
import base64
import requests
from odoo import models, fields, api, _
from odoo.exceptions import UserError

_logger = logging.getLogger(__name__)


class ProductTemplate(models.Model):
    _inherit = 'product.template'

    chatgpt_enriched = fields.Boolean(
        string='Enriched by ChatGPT',
        default=False,
        readonly=True,
        help='Indicates if this product has been enriched by ChatGPT'
    )
    
    chatgpt_content = fields.Html(
        string='AI Generated Content',
        readonly=True,
        help='Content generated by ChatGPT'
    )
    
    chatgpt_last_enrichment = fields.Datetime(
        string='Last Enrichment Date',
        readonly=True,
        help='Date and time of last ChatGPT enrichment'
    )
    
    chatgpt_media_urls = fields.Text(
        string='AI Discovered Media',
        readonly=True,
        help='URLs of official images and videos found by AI'
    )

    chatgpt_log = fields.Html(string='Enrichment Log', readonly=True)
    chatgpt_web_search_log = fields.Html(string='Web Search Log', readonly=True)
    chatgpt_deep_enrichment_log = fields.Html(string='Deep Enrichment Log', readonly=True)
    chatgpt_last_enrichment = fields.Datetime(string='Last AI Enrichment', readonly=True)
    chatgpt_auto_align = fields.Boolean(string='Auto-Align Market Price', default=True, help="If checked, this product will be automatically processed by the scheduler.")
    chatgpt_raw_serp_results = fields.Html(string='Raw Search Data', readonly=True)
    chatgpt_suggested_price = fields.Float(string='AI Suggested Price', compute='_compute_suggested_price', help="Suggested price based on global alignment strategy.")

    chatgpt_competitor_price_ids = fields.One2many(
        'product.competitor.price', 'product_tmpl_id', 
        string='Competitor Prices (France)'
    )
    
    chatgpt_video_ids = fields.One2many(
        'product.video.link', 'product_tmpl_id', 
        string='Official Videos'
    )

    chatgpt_config_id = fields.Many2one('chatgpt.config', compute='_compute_chatgpt_config', string='Active AI Configuration')
    chatgpt_prompt_ids = fields.Many2many('chatgpt.product.prompt', string='Active Prompts', compute='_compute_chatgpt_config')

    def _compute_chatgpt_config(self):
        config = self.env['chatgpt.config'].search([('active', '=', True)], limit=1)
        for record in self:
            record.chatgpt_config_id = config.id
            record.chatgpt_prompt_ids = config.prompt_ids.ids if config else []

    @api.model_create_multi
    def create(self, vals_list):
        """Override create to auto-enrich products if enabled"""
        records = super(ProductTemplate, self).create(vals_list)
        
        # Check if auto-enrichment is enabled
        try:
            config = self.env['chatgpt.config'].get_active_config()
            if config.auto_enrich:
                for record in records:
                    if record.name and not record.chatgpt_enriched:
                        try:
                            record._enrich_with_chatgpt()
                        except Exception as e:
                            _logger.warning('Auto-enrichment failed for product %s: %s', record.name, str(e))
                            # Don't block product creation if enrichment fails
        except Exception as e:
            _logger.warning('Could not check auto-enrich config: %s', str(e))
            
        return records

    def action_enrich_with_chatgpt(self):
        """Manual action to enrich product with ChatGPT"""
        self.ensure_one()
        
        if not self.name:
            raise UserError(_('Product must have a name before enrichment.'))
        
        self._enrich_with_chatgpt()
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Success'),
                'message': _('Product enriched successfully with ChatGPT!'),
                'type': 'success',
                'sticky': False,
            }
        }

    def _enrich_with_chatgpt(self):
        """Internal method to enrich product using multiple prompts from config"""
        self.ensure_one()
        
        # Get active configuration
        config = self.env['chatgpt.config'].get_active_config()
        
        if not config.prompt_ids:
            raise UserError(_('No prompts configured in ChatGPT Configuration.'))
        
        _logger.info('Enriching product: %s', self.name)
        
        vals = {
            'chatgpt_enriched': True,
            'chatgpt_last_enrichment': fields.Datetime.now(),
            'chatgpt_log': f"<p>Starting enrichment for <b>{self.name}</b>...</p>",
        }
        
        # 1. Technical Fact Discovery (Web Search) - SPECIFICATIONS ONLY
        scraped_data = ""
        if config.use_web_search:
            vals['chatgpt_web_search_log'] = f"<p><i class='fa fa-microchip'/> Researching technical characteristics...</p>"
            # Use custom technical prompt if available
            tech_prompt = (config.prompt_technical_research or "Research ONLY technical specifications for {product_name}.").format(product_name=self.name)
            research_res = config.call_ai_api(tech_prompt)
            research_res = re.sub(r'```(html|json|xml)?', '', research_res).replace('```', '').strip()
            vals['chatgpt_web_search_log'] += f"<div class='research-results'>{research_res}</div>"
            scraped_data += f"\n--- Technical Web Research ---\n{research_res}\n"

        # 2. Scraping Layer (Deep Enrichment) - INCLUDES PRICES
        if config.use_deep_enrichment:
            deep_log = f"<p><i class='fa fa-deep-enrichment'/> Running Deep Scraping phase...</p><ul>"
            raw_serp = "<div class='serp-results'><h5><i class='fa fa-google mr-2 text-primary'/> Market Data Discovery</h5>"
            if config.target_competitors:
                raw_serp += f"<div class='alert alert-info py-1 mb-2'>Targeting: {config.target_competitors.replace('\\n', ', ')}</div>"
            raw_serp += "<div class='list-group list-group-flush border rounded'>"
            
            search_query = self.name
            if config.target_competitors:
                search_query += " (" + " OR ".join(config.target_competitors.splitlines()) + ")"
                
            search_results = config._search_with_serpapi(search_query)
            for res in search_results:
                url = res.get('link')
                title = res.get('title', 'Unknown Title')
                snippet = res.get('snippet', '')
                if not url: continue
                
                deep_log += f"<li>Analyzing <a href='{url}' target='_blank'>{title}</a>...</li>"
                raw_serp += f"<div class='list-group-item p-2'><a href='{url}' target='_blank' class='fw-bold'>{title}</a><br/><small class='text-muted' style='font-size: 0.8em;'>{snippet}</small></div>"
                
                content = config._scrape_with_scrapingbee(url)
                scraped_data += f"\n--- Content from {title} ({url}) ---\n{content}\n"
            
            deep_log += "</ul>"
            raw_serp += "</div></div>"
            vals['chatgpt_deep_enrichment_log'] = deep_log
            vals['chatgpt_raw_serp_results'] = raw_serp
        
        all_content = []
        
        system_instruction = (
            "You are an expert product data analyst. Always provide accurate technical details. "
            "IMPORTANT: Return ONLY clean text or HTML as requested. NO markdown backticks. "
            "For product descriptions, return ONLY the description content, NO field labels like 'Description:' or JSON syntax. "
            "If JSON is requested, use these exact keys: 'weight', 'description_sale', "
            "'prices_france' (list of {'source': domain, 'price': float, 'url': url} - aim for 5+ competitors), "
            "'youtube_videos' (list of {'name': title, 'url': url}), "
            "'technical_bullets' (list of strings)."
        )

        for p in config.prompt_ids:
            if not p.active:
                continue
                
            prompt = f"{system_instruction}\nAnswer in {dict(p._fields['language'].selection).get(p.language, 'French')}. "
            if scraped_data:
                prompt += f"CONTEXT DATA:\n{scraped_data}\n"
            prompt += p.prompt_template.format(product_name=self.name)
            
            if "JSON" in prompt.upper() or "STRUCTURED" in prompt.upper():
                prompt += "\nReturn ONLY valid JSON."
            
            enriched_content = config.call_ai_api(prompt)
            # Remove markdown backticks
            enriched_content = re.sub(r'```(html|json|xml)?', '', enriched_content).replace('```', '').strip()
            
            vals['chatgpt_log'] += f"<p><b>Prompt '{p.name}':</b> Executed.</p>"
            
            try:
                # Attempt to extract JSON even if there's other text
                json_start = enriched_content.find('{')
                json_end = enriched_content.rfind('}') + 1
                if json_start >= 0 and json_end > json_start:
                    maybe_json = enriched_content[json_start:json_end]
                    json_data = json.loads(maybe_json)
                    
                    if 'prices_france' in json_data and isinstance(json_data['prices_france'], list):
                        self.chatgpt_competitor_price_ids.unlink() # Refresh prices
                        for pr in json_data['prices_france']:
                            if pr.get('price'):
                                self.env['product.competitor.price'].create({
                                    'product_tmpl_id': self.id,
                                    'source': pr.get('source'),
                                    'price': float(pr.get('price', 0)),
                                    'url': pr.get('url'),
                                })

                    if 'youtube_videos' in json_data and isinstance(json_data['youtube_videos'], list):
                        # Don't unlink, just update/append unique ones
                        for v in json_data['youtube_videos']:
                            if v.get('url'):
                                if not self.chatgpt_video_ids.filtered(lambda x: x.video_url == v.get('url')):
                                    self.env['product.video.link'].create({
                                        'product_tmpl_id': self.id,
                                        'name': v.get('name') or _('Official Media'),
                                        'video_url': v.get('url'),
                                        'platform': 'youtube'
                                    })

                    media_keys = ['image_urls', 'images', 'media']
                    for mk in media_keys:
                        if mk in json_data and isinstance(json_data[mk], list):
                            self._import_media_from_urls(json_data[mk])

                    for key, value in json_data.items():
                        if key in self._fields and not vals.get(key) and key not in ['chatgpt_competitor_price_ids', 'chatgpt_video_ids']:
                            field = self._fields[key]
                            
                            # ROBUST TYPE CONVERSION (Fixes RPC_ERROR ValueError)
                            if value in [None, 'N/A', 'n/a', '', 'None']:
                                continue
                                
                            try:
                                if field.type in ['float', 'monetary']:
                                    # Extract number even if it has currency symbols
                                    if isinstance(value, str):
                                        nums = re.findall(r'(\d+[.,]\d+|\d+)', value)
                                        value = float(nums[0].replace(',', '.')) if nums else 0.0
                                    vals[key] = float(value)
                                elif field.type == 'integer':
                                    vals[key] = int(float(value)) if value else 0
                                elif field.type == 'boolean':
                                    vals[key] = bool(value)
                                elif key == 'description_sale' and isinstance(value, str):
                                    clean_val = re.sub(r'^\{?"description_sale":\s*"?', '', value)
                                    clean_val = re.sub(r'"?\}?$', '', clean_val).strip()
                                    vals[key] = clean_val
                                else:
                                    vals[key] = value
                            except (ValueError, TypeError, IndexError):
                                _logger.warning("Failed to convert value %s for field %s", value, key)
                                continue
                    
                    # If we mapped a description, use it as the clean content for the dashboard
                    if 'description_sale' in json_data:
                        enriched_content = json_data['description_sale']
                else:
                    # Not JSON, but let's clean it anyway for the dashboard
                    enriched_content = re.sub(r'^\{?"description_sale":\s*"?', '', enriched_content)
                    enriched_content = re.sub(r'"?\}?$', '', enriched_content).strip()

            except Exception as e:
                _logger.warning('Failed to parse AI response as JSON or clean it: %s', str(e))

            if p.target_field_id and p.target_field_id.name in self._fields:
                vals[p.target_field_id.name] = enriched_content
            
            # Universal media extraction from raw text (back-up)
            urls = re.findall(r'https?://[^\s<>"]+|www\.[^\s<>"]+', enriched_content)
            if urls:
                self._import_media_from_urls(urls)
                for url in urls:
                    if 'youtube.com' in url or 'youtu.be' in url:
                        if not self.chatgpt_video_ids.filtered(lambda v: v.video_url == url):
                            self.env['product.video.link'].create({
                                'product_tmpl_id': self.id,
                                'name': _('Official Discovery'),
                                'video_url': url,
                                'platform': 'youtube'
                            })
                
                existing_media_urls = vals.get('chatgpt_media_urls', '') or ''
                new_media_urls = "\n".join(list(set(urls)))
                vals['chatgpt_media_urls'] = (existing_media_urls + "\n" + new_media_urls).strip()
            
            all_content.append(enriched_content) # Just content for clean look
            
        vals['chatgpt_content'] = "\n\n".join(all_content)
        vals['chatgpt_log'] += "<p class='text-success'><b>Done!</b> Enrichment completed.</p>"
        self.write(vals)
        
        # Trigger alignment if global config says so
        if config.price_alignment_strategy != 'none':
            self.action_align_price()
        
    def _compute_suggested_price(self):
        config = self.env['chatgpt.config'].get_active_config()
        for record in self:
            record.chatgpt_suggested_price = 0
            if record.chatgpt_competitor_price_ids and config.price_alignment_strategy != 'none':
                prices = record.chatgpt_competitor_price_ids.filtered(lambda p: p.price > 0).mapped('price')
                if prices:
                    target = 0
                    if config.price_alignment_strategy == 'lowest':
                        target = min(prices)
                    elif config.price_alignment_strategy == 'average':
                        target = sum(prices) / len(prices)
                    
                    if target > 0:
                        offset = config.price_alignment_offset
                        if config.price_alignment_offset_type == 'percentage':
                            offset = (target * config.price_alignment_offset_pct) / 100.0
                        record.chatgpt_suggested_price = target + offset
        
        _logger.info('Product %s enriched successfully', self.name)

    def action_align_price(self):
        """Align product price based on competitors"""
        self.ensure_one()
        if self.chatgpt_suggested_price > 0:
            old_price = self.list_price
            self.list_price = self.chatgpt_suggested_price
            msg = _("<b>Price Alignment:</b> Sale price updated from %s to <b>%s</b> based on AI market analysis.") % (old_price, self.list_price)
            self.message_post(body=msg)
        else:
            raise UserError(_("No suggested price available. Ensure competitor prices are extracted first."))

    def _import_media_from_urls(self, urls):
        """Download images from URLs and import them into Odoo"""
        if not urls:
            return
            
        processed_urls = []
        for url in urls:
            if not any(ext in url.lower() for ext in ['.jpg', '.jpeg', '.png', '.webp']):
                continue
            if url in processed_urls:
                continue
            
            try:
                _logger.info('Importing image: %s', url)
                response = requests.get(url, timeout=10)
                if response.status_code == 200:
                    image_data = base64.b64encode(response.content)
                    
                    # Set main image if not already set
                    if not self.image_1920:
                        self.image_1920 = image_data
                        _logger.info('Set main product image from %s', url)
                    else:
                        # Add to extra media
                        # Check if already exists
                        existing = self.env['product.image'].search([
                            ('product_tmpl_id', '=', self.id),
                            ('name', 'ilike', url.split('/')[-1][:10])
                        ], limit=1)
                        
                        if not existing:
                            self.env['product.image'].create({
                                'name': url.split('/')[-1] or 'AI Discovered Image',
                                'product_tmpl_id': self.id,
                                'image_1920': image_data,
                            })
                            _logger.info('Added extra media from %s', url)
                
                processed_urls.append(url)
                if len(processed_urls) >= 10: # Increased limit
                    break
            except Exception as e:
                _logger.warning('Failed to import image from %s: %s', url, str(e))

    def action_run_deep_search(self):
        """Dedicated action for deep enrichment phase only"""
        self.ensure_one()
        # Force set config to use deep enrichment for this run
        config = self.env['chatgpt.config'].get_active_config()
        if not config.use_deep_enrichment:
            raise UserError(_("Deep Enrichment is disabled in global settings. Please enable it first."))
        return self.action_enrich_with_chatgpt()

    def action_enrich_batch(self):
        """Action for batch enrichment of multiple products"""
        for record in self:
            try:
                record._enrich_with_chatgpt()
            except Exception as e:
                _logger.error('Batch enrichment failed for %s: %s', record.name, str(e))
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Batch Enrichment'),
                'message': _('Enrichment process completed for selected products.'),
                'type': 'success',
                'sticky': False,
            }
        }

    def action_clear_enrichment(self):
        """Clear ChatGPT enrichment data"""
        self.ensure_one()
        vals = {
            'chatgpt_enriched': False,
            'chatgpt_content': False,
            'chatgpt_last_enrichment': False,
            'chatgpt_media_urls': False,
        }
        if 'description_sale' in self._fields:
            vals['description_sale'] = False
        if 'description' in self._fields:
            vals['description'] = False
        if 'website_description' in self._fields:
            vals['website_description'] = False
            
        self.write(vals)
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Success'),
                'message': _('ChatGPT enrichment data cleared.'),
                'type': 'info',
                'sticky': False,
            }
        }

    def action_view_chatgpt_enrichment(self):
        """Dummy action for stat button to satisfy Odoo requirements"""
        return True


class ProductCompetitorPrice(models.Model):
    _name = 'product.competitor.price'
    _description = 'Competitor Price Tracking'

    product_tmpl_id = fields.Many2one('product.template', string='Product', ondelete='cascade')
    source = fields.Char(string='Source (Domain)')
    price = fields.Float(string='Price')
    currency_id = fields.Many2one('res.currency', string='Currency', default=lambda self: self.env.ref('base.EUR').id)
    url = fields.Char(string='URL')
    last_update = fields.Datetime(string='Last Scraped', default=fields.Datetime.now)


class ProductVideoLink(models.Model):
    _name = 'product.video.link'
    _description = 'Official Video Links'

    product_tmpl_id = fields.Many2one('product.template', string='Product', ondelete='cascade')
    name = fields.Char(string='Title')
    video_url = fields.Char(string='Video URL')
    platform = fields.Selection([('youtube', 'YouTube'), ('other', 'Other')], string='Platform', default='youtube')
    icon = fields.Char(compute='_compute_icon')

    @api.depends('platform')
    def _compute_icon(self):
        for record in self:
            if record.platform == 'youtube':
                record.icon = 'fa-youtube'
            else:
                record.icon = 'fa-play-circle'

    def action_open_video(self):
        """Redirect to the video URL"""
        self.ensure_one()
        return {
            'type': 'ir.actions.act_url',
            'url': self.video_url,
            'target': 'new',
        }
