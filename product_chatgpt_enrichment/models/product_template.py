import logging
import re
import json
import base64
import requests
from odoo import models, fields, api, _

_logger = logging.getLogger(__name__)


class ProductTemplate(models.Model):
    _inherit = 'product.template'

    chatgpt_enriched = fields.Boolean(
        string='Enriched by ChatGPT',
        default=False,
        readonly=True,
        help='Indicates if this product has been enriched by ChatGPT'
    )
    
    chatgpt_content = fields.Html(
        string='AI Generated Content',
        readonly=True,
        help='Content generated by ChatGPT'
    )
    
    chatgpt_last_enrichment = fields.Datetime(
        string='Last Enrichment Date',
        readonly=True,
        help='Date and time of last ChatGPT enrichment'
    )
    
    chatgpt_media_urls = fields.Text(
        string='AI Discovered Media',
        readonly=True,
        help='URLs of official images and videos found by AI'
    )

    chatgpt_log = fields.Html(string='Enrichment Log', readonly=True)
    chatgpt_web_search_log = fields.Html(string='Web Search Log', readonly=True)
    chatgpt_deep_enrichment_log = fields.Html(string='Deep Enrichment Log', readonly=True)

    chatgpt_competitor_price_ids = fields.One2many(
        'product.competitor.price', 'product_tmpl_id', 
        string='Competitor Prices (France)'
    )
    
    chatgpt_video_ids = fields.One2many(
        'product.video.link', 'product_tmpl_id', 
        string='Official Videos'
    )

    chatgpt_config_id = fields.Many2one('chatgpt.config', compute='_compute_chatgpt_config', string='Active AI Configuration')
    chatgpt_prompt_ids = fields.Many2many('chatgpt.product.prompt', string='Active Prompts', compute='_compute_chatgpt_config')

    def _compute_chatgpt_config(self):
        config = self.env['chatgpt.config'].search([('active', '=', True)], limit=1)
        for record in self:
            record.chatgpt_config_id = config.id
            record.chatgpt_prompt_ids = config.prompt_ids.ids if config else []

    @api.model_create_multi
    def create(self, vals_list):
        """Override create to auto-enrich products if enabled"""
        records = super(ProductTemplate, self).create(vals_list)
        
        # Check if auto-enrichment is enabled
        try:
            config = self.env['chatgpt.config'].get_active_config()
            if config.auto_enrich:
                for record in records:
                    if record.name and not record.chatgpt_enriched:
                        try:
                            record._enrich_with_chatgpt()
                        except Exception as e:
                            _logger.warning('Auto-enrichment failed for product %s: %s', record.name, str(e))
                            # Don't block product creation if enrichment fails
        except Exception as e:
            _logger.warning('Could not check auto-enrich config: %s', str(e))
            
        return records

    def action_enrich_with_chatgpt(self):
        """Manual action to enrich product with ChatGPT"""
        self.ensure_one()
        
        if not self.name:
            raise UserError(_('Product must have a name before enrichment.'))
        
        self._enrich_with_chatgpt()
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Success'),
                'message': _('Product enriched successfully with ChatGPT!'),
                'type': 'success',
                'sticky': False,
            }
        }

    def _enrich_with_chatgpt(self):
        """Internal method to enrich product using multiple prompts from config"""
        self.ensure_one()
        
        # Get active configuration
        config = self.env['chatgpt.config'].get_active_config()
        
        if not config.prompt_ids:
            raise UserError(_('No prompts configured in ChatGPT Configuration.'))
        
        _logger.info('Enriching product: %s', self.name)
        
        vals = {
            'chatgpt_enriched': True,
            'chatgpt_last_enrichment': fields.Datetime.now(),
            'chatgpt_log': f"<p>Starting enrichment for <b>{self.name}</b>...</p>",
        }
        
        # 1. Web Search Layer (Log)
        if config.use_web_search:
            vals['chatgpt_web_search_log'] = f"<p><i class='fa fa-search'/> Performing web search for latest info...</p>"

        # 2. Scraping Layer (Deep Enrichment)
        scraped_data = ""
        if config.use_deep_enrichment:
            deep_log = f"<p><i class='fa fa-deep-enrichment'/> Running Deep Enrichment phase...</p><ul>"
            urls = config._search_with_serpapi(self.name)
            for url in urls:
                deep_log += f"<li>Scraping <a href='{url}' target='_blank'>{url}</a>...</li>"
                content = config._scrape_with_scrapingbee(url)
                scraped_data += f"\n--- Content from {url} ---\n{content}\n"
            deep_log += "</ul>"
            vals['chatgpt_deep_enrichment_log'] = deep_log
        
        all_content = []
        
        # System instruction to force specific JSON keys
        system_instruction = (
            "You are an expert product data analyst. Always provide accurate technical details. "
            "If requested in JSON, use these exact keys if found: 'weight', 'description_sale', "
            "'prices_france' (list of {'source': domain, 'price': float, 'url': url}), "
            "'youtube_videos' (list of {'name': title, 'url': url}), "
            "'technical_bullets' (list of strings)."
        )

        for p in config.prompt_ids:
            if not p.active:
                continue
                
            # Prepare the prompt
            lang_name = dict(p._fields['language'].selection).get(p.language, 'French')
            prompt = f"{system_instruction}\nAnswer in {lang_name}. "
            
            if config.use_deep_enrichment and scraped_data:
                prompt += "Use the following scraped context to extract real specifications and French prices. "
                prompt += f"CONTEXT DATA:\n{scraped_data}\n"
            else:
                if config.media_discovery:
                    prompt += "Find official YouTube video links and high-res image URLs. "
                if config.use_web_search:
                    prompt += "Search for the current market price in France and official model specs. "
            
            prompt += p.prompt_template.format(product_name=self.name)
            
            # Request JSON if needed
            if "JSON" in prompt.upper() or "STRUCTURED" in prompt.upper():
                prompt += "\nReturn ONLY valid JSON."
            
            # Call AI API
            enriched_content = config.call_ai_api(prompt)
            vals['chatgpt_log'] += f"<p><b>Prompt '{p.name}':</b> Response received.</p>"
            
            # Try to parse JSON if content looks like JSON
            try:
                if enriched_content.strip().startswith('{'):
                    json_data = json.loads(enriched_content)
                    
                    # 1. Extract Competitor Prices
                    if 'prices_france' in json_data and isinstance(json_data['prices_france'], list):
                        self.chatgpt_competitor_price_ids.unlink() # Refresh
                        for pr in json_data['prices_france']:
                            self.env['product.competitor.price'].create({
                                'product_tmpl_id': self.id,
                                'source': pr.get('source'),
                                'price': float(pr.get('price', 0)),
                                'url': pr.get('url'),
                            })

                    # 2. Extract YouTube Videos
                    if 'youtube_videos' in json_data and isinstance(json_data['youtube_videos'], list):
                        self.chatgpt_video_ids.unlink() # Refresh
                        for v in json_data['youtube_videos']:
                            self.env['product.video.link'].create({
                                'product_tmpl_id': self.id,
                                'name': v.get('name'),
                                'video_url': v.get('url'),
                                'platform': 'youtube'
                            })

                    # 3. Handle Media URLs
                    media_keys = ['image_urls', 'images', 'media']
                    for mk in media_keys:
                        if mk in json_data and isinstance(json_data[mk], list):
                            self._import_media_from_urls(json_data[mk])

                    # Batch map JSON fields if target_field_id is not set or custom
                    for key, value in json_data.items():
                        if key in self._fields and not vals.get(key) and key not in ['chatgpt_competitor_price_ids', 'chatgpt_video_ids']:
                            vals[key] = value
                    
                    enriched_content = json.dumps(json_data, indent=2, ensure_ascii=False)
            except Exception as e:
                _logger.warning('Failed to parse AI response as JSON: %s', str(e))

            if p.target_field_id and p.target_field_id.name in self._fields:
                vals[p.target_field_id.name] = enriched_content
            
            # Generic URL discovery for media
            if config.media_discovery or config.use_deep_enrichment:
                urls = re.findall(r'https?://[^\s<>"]+|www\.[^\s<>"]+', enriched_content)
                if urls:
                    self._import_media_from_urls(urls)
                    existing_urls = vals.get('chatgpt_media_urls', '') or ''
                    new_urls = "\n".join(list(set(urls)))
                    vals['chatgpt_media_urls'] = (existing_urls + "\n" + new_urls).strip()
            
            all_content.append(f"<h3>{p.name}</h3>\n{enriched_content}")
            
        vals['chatgpt_content'] = "\n".join(all_content)
        vals['chatgpt_log'] += "<p class='text-success'><b>Done!</b> Enrichment completed.</p>"
        self.write(vals)
        _logger.info('Product %s enriched successfully', self.name)

    def _import_media_from_urls(self, urls):
        """Download images from URLs and import them into Odoo"""
        if not urls:
            return
            
        processed_urls = []
        for url in urls:
            if not any(ext in url.lower() for ext in ['.jpg', '.jpeg', '.png', '.webp']):
                continue
            if url in processed_urls:
                continue
            
            try:
                _logger.info('Importing image: %s', url)
                response = requests.get(url, timeout=10)
                if response.status_code == 200:
                    image_data = base64.b64encode(response.content)
                    
                    # Set main image if not already set
                    if not self.image_1920:
                        self.image_1920 = image_data
                        _logger.info('Set main product image from %s', url)
                    else:
                        # Add to extra media
                        # Check if already exists
                        existing = self.env['product.image'].search([
                            ('product_tmpl_id', '=', self.id),
                            ('name', 'ilike', url.split('/')[-1][:10])
                        ], limit=1)
                        
                        if not existing:
                            self.env['product.image'].create({
                                'name': url.split('/')[-1] or 'AI Discovered Image',
                                'product_tmpl_id': self.id,
                                'image_1920': image_data,
                            })
                            _logger.info('Added extra media from %s', url)
                
                processed_urls.append(url)
                if len(processed_urls) >= 10: # Increased limit
                    break
            except Exception as e:
                _logger.warning('Failed to import image from %s: %s', url, str(e))

    def action_run_deep_search(self):
        """Dedicated action for deep enrichment phase only"""
        self.ensure_one()
        # Force set config to use deep enrichment for this run
        config = self.env['chatgpt.config'].get_active_config()
        if not config.use_deep_enrichment:
            raise UserError(_("Deep Enrichment is disabled in global settings. Please enable it first."))
        return self.action_enrich_with_chatgpt()

    def action_enrich_batch(self):
        """Action for batch enrichment of multiple products"""
        for record in self:
            try:
                record._enrich_with_chatgpt()
            except Exception as e:
                _logger.error('Batch enrichment failed for %s: %s', record.name, str(e))
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Batch Enrichment'),
                'message': _('Enrichment process completed for selected products.'),
                'type': 'success',
                'sticky': False,
            }
        }

    def action_clear_enrichment(self):
        """Clear ChatGPT enrichment data"""
        self.ensure_one()
        vals = {
            'chatgpt_enriched': False,
            'chatgpt_content': False,
            'chatgpt_last_enrichment': False,
            'chatgpt_media_urls': False,
        }
        if 'description_sale' in self._fields:
            vals['description_sale'] = False
        if 'description' in self._fields:
            vals['description'] = False
        if 'website_description' in self._fields:
            vals['website_description'] = False
            
        self.write(vals)
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Success'),
                'message': _('ChatGPT enrichment data cleared.'),
                'type': 'info',
                'sticky': False,
            }
        }

    def action_view_chatgpt_enrichment(self):
        """Dummy action for stat button to satisfy Odoo requirements"""
        return True


class ProductCompetitorPrice(models.Model):
    _name = 'product.competitor.price'
    _description = 'Competitor Price Tracking'

    product_tmpl_id = fields.Many2one('product.template', string='Product', ondelete='cascade')
    source = fields.Char(string='Source (Domain)')
    price = fields.Float(string='Price')
    currency_id = fields.Many2one('res.currency', string='Currency', default=lambda self: self.env.ref('base.EUR').id)
    url = fields.Char(string='URL')
    last_update = fields.Datetime(string='Last Scraped', default=fields.Datetime.now)


class ProductVideoLink(models.Model):
    _name = 'product.video.link'
    _description = 'Official Video Links'

    product_tmpl_id = fields.Many2one('product.template', string='Product', ondelete='cascade')
    name = fields.Char(string='Title')
    video_url = fields.Char(string='Video URL')
    platform = fields.Selection([('youtube', 'YouTube'), ('other', 'Other')], string='Platform', default='youtube')
    icon = fields.Char(compute='_compute_icon')

    @api.depends('platform')
    def _compute_icon(self):
        for record in self:
            if record.platform == 'youtube':
                record.icon = 'fa-youtube'
            else:
                record.icon = 'fa-play-circle'

    def action_open_video(self):
        """Redirect to the video URL"""
        self.ensure_one()
        return {
            'type': 'ir.actions.act_url',
            'url': self.video_url,
            'target': 'new',
        }
